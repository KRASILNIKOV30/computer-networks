# C++ HTTP Proxy Server с Кэшированием

Данный проект представляет собой реализацию многопоточного HTTP прокси-сервера. Сервер принимает GET-запросы от клиентов (браузеров, утилит curl), перенаправляет их целевым веб-серверам, сохраняет полученные ответы на локальном диске и использует их для ускорения последующих запросов к тем же ресурсам.

### Инструкция по сборке

1.  Перейдите в директорию проекта:
    ```bash
    cd projects/computer-networks/http_proxy
    ```
2.  Создайте директорию для сборки:
    ```bash
    mkdir -p build && cd build
    ```
3.  Запустите CMake и компиляцию:
    ```bash
    cmake ..
    make
    ```

### Запуск сервера
После успешной сборки запустите исполняемый файл, указав желаемый порт

```bash
./http_proxy 8080
```

После запуска в текущей директории будет создана папка `./cache`, куда будут сохраняться кэшированные файлы.

## Описание Алгоритма Кэширования

Алгоритм кэширования, реализованный в данном прокси-сервере, основан на принципе перехвата запросов и локального сохранения статического контента. Ниже приведено подробное описание логики работы системы.

### 1. Идентификация ресурсов (Cache Key Generation)

В основе кэширования лежит задача однозначной идентификации запрашиваемого ресурса. В протоколе HTTP уникальным идентификатором ресурса является URL (Uniform Resource Locator).

Однако использование "сырого" URL в качестве имени файла в файловой системе невозможно по нескольким причинам:
*   URL может содержать спецсимволы (`/`, `:`, `?`, `*`), запрещенные в именах файлов.
*   Длина URL может превышать ограничения файловой системы (обычно 255 байт для имени файла).

**Решение:**
В программе используется алгоритм хэширования.
1.  Прокси получает полный URL запроса (например, `http://info.cern.ch/hypertext/WWW/TheProject.html`).
2.  Вычисляется хэш-сумма этой строки с использованием стандартного функтора `std::hash<std::string>`.
3.  Полученное числовое значение (например, `16482934012`) преобразуется в строку и используется как имя файла.

Таким образом, `Map(URL) -> Filename` является детерминированным отображением.

### 2. Структура хранения

Все данные сохраняются в директорию `./cache`. Файлы хранятся в бинарном виде. Это критически важно, так как HTTP-ответы могут содержать не только текст (HTML, CSS, JS), но и мультимедиа (изображения PNG/JPEG, архивы).

При сохранении данные записываются "как есть" — то есть тело ответа от сервера сохраняется байт-в-байт. В текущей базовой реализации заголовки HTTP от целевого сервера не сохраняются в метаданных файла, прокси генерирует их динамически или транслирует поток (в расширенных версиях обычно сохраняются и заголовки `Content-Type`, `Expires`).

### 3. Логика обработки запроса (Request Flow)

Процесс обработки каждого соединения (`HandleClient`) проходит через следующие этапы:

#### Этап А: Анализ запроса
1.  Сервер считывает первый пакет данных от клиента.
2.  Парсер (`HttpUtils`) анализирует строку запроса:
    *   Проверяется метод: поддерживается только **GET**.
    *   Извлекается **Host** (доменное имя) и **Port** (по умолчанию 80).
    *   Формируется полный **Target URL**.

#### Этап Б: Проверка кэша
1.  Система вычисляет путь к предполагаемому файлу кэша: `./cache/{HASH_URL}`.
2.  Проверяется существование файла с помощью `std::filesystem::exists`.

#### Этап В: Сценарий "Cache HIT"
Если файл найден:
1.  Прокси не устанавливает соединение с внешним интернетом.
2.  Открывается локальный файл на чтение в бинарном режиме.
3.  Данные считываются буферами (по 4КБ) и отправляются в сокет клиента.
4.  **Результат:** Мгновенная загрузка, отсутствие сетевых задержек, экономия трафика.

#### Этап Г: Сценарий "Cache MISS"
Если файл не найден:
1.  **Соединение:** Прокси инициирует TCP-соединение с целевым сервером (`UpstreamConnection`).
2.  **Запрос:** Формируется и отправляется HTTP-запрос (с преобразованием абсолютного URL в относительный, как того требует стандарт HTTP/1.1 при общении с сервером напрямую).
3.  **Потоковая передача (Streaming/Teeing):**
    *   Прокси не ждет полной загрузки файла в память (что могло бы вызвать переполнение памяти на больших файлах).
    *   Вместо этого используется циклический буфер.
    *   В цикле `while(recv(...) > 0)`:
        *   Полученная порция данных записывается в локальный файл кэша (`ofstream`).
        *   Эта же порция данных немедленно отправляется клиенту (`send`).
4.  **Завершение:** После окончания передачи соединение закрывается, а на диске остается полная копия файла.
