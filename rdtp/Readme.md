
# Reliable Data Transfer Protocol (RDTP)

Данный документ описывает архитектуру и детали реализации протокола **RDTP (Reliable Data Transfer Protocol)**. Протокол предназначен для надежной передачи файлов между клиентом (Sender) и сервером (Receiver) поверх ненадежного транспортного уровня (UDP).

Система спроектирована для работы в условиях:
*   Потери пакетов.
*   Повреждения данных.
*   Задержек и дублирования пакетов.

Основной механизм обеспечения надежности базируется на алгоритме **Go-Back-N (GBN)** с использованием скользящего окна и кумулятивных подтверждений (Cumulative ACKs).

## 2. Формат пакетов (Packet Format)

Протокол использует бинарный формат пакетов с фиксированным заголовком и переменной полезной нагрузкой. Максимальный размер пакета (MTU) ограничен **1412 байтами** (12 байт заголовок + 1400 байт данных), что гарантирует прохождение через стандартные Ethernet-сети без IP-фрагментации.

### 2.1. Структура заголовка

Размер заголовка составляет **12 байт**. Поля упакованы (attribute packed не требуется при ручной сериализации, но порядок байт — Big Endian / Network Byte Order).

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Flags     |    Reserved   |          Data Length          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |          Magic Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                       Payload (Variable)                      |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### 2.2. Описание полей

| Поле | Тип | Размер | Описание |
|:---|:---|:---|:---|
| **Sequence Number** | `uint32_t` | 4 байта | Порядковый номер пакета. Для пакетов данных — номер сегмента. Для ACK — номер ожидаемого следующего пакета. |
| **Flags** | `uint8_t` | 1 байт | Управляющие флаги (см. п. 2.3). |
| **Reserved** | `uint8_t` | 1 байт | Зарезервировано для выравнивания (должно быть 0). |
| **Data Length** | `uint16_t` | 2 байта | Длина полезной нагрузки в байтах (без учета заголовка). |
| **Checksum** | `uint16_t` | 2 байта | 16-битная сумма (Internet Checksum) заголовка и данных. Используется для обнаружения битовых ошибок. |
| **Magic Number** | `uint16_t` | 2 байта | Константа `0xC0DE`. Используется для фильтрации "мусорных" пакетов, не относящихся к протоколу. |

### 2.3. Флаги (Flags)

Флаги могут комбинироваться побитовым ИЛИ:

*   `0x01` **SYN**: Запрос на начало передачи (Handshake).
*   `0x02` **ACK**: Подтверждение получения.
*   `0x04` **FIN**: Запрос на завершение передачи (Teardown).
*   `0x08` **DATA**: Пакет несет часть передаваемого файла.

---

## 3. Выбранные алгоритмы

### 3.1. Go-Back-N (GBN)
Для управления потоком и обработкой потерь выбран алгоритм GBN:

*   **Отправитель (Sender):**
    *   Поддерживает окно размером $N$ (Window Size).
    *   Может отправить до $N$ пакетов без получения подтверждения.
    *   Поддерживает таймер для *самого старого* неподтвержденного пакета (`Base`).
    *   При таймауте происходит событие **Retransmit**: повторная отправка всех пакетов в окне (от `Base` до `NextSeqNum - 1`).
    *   При получении `ACK(n)` окно сдвигается: `Base = n + 1`.

*   **Получатель (Receiver):**
    *   Использует простую логику: принимает только пакет с ожидаемым номером последовательности (`ExpectedSeqNum`).
    *   Если приходит пакет с `SeqNum == ExpectedSeqNum` (и верной контрольной суммой):
        *   Данные записываются.
        *   Отправляется `ACK(ExpectedSeqNum)`.
        *   `ExpectedSeqNum` увеличивается.
    *   Если приходит пакет "из будущего" (нарушение порядка) или поврежденный пакет:
        *   Пакет отбрасывается (буферизация отсутствует, в отличие от Selective Repeat).
        *   Повторно отправляется `ACK` для последнего успешно принятого пакета.

### 3.2. Контрольная сумма (Checksum)
Используется стандартный алгоритм **Internet Checksum** (RFC 1071):
1.  Данные рассматриваются как последовательность 16-битных целых чисел.
2.  Вычисляется сумма в дополнительном коде (ones' complement sum).
3.  Результат инвертируется.
    При проверке сумма всех слов, включая поле Checksum, должна давать `0xFFFF` (или `0x0000`).

---

## 4. Конечный автомат

### 4.1. FSM Отправителя

Отправитель имеет три основных состояния:

1.  **HANDSHAKE (Установление связи):**
    *   **Вход:** Запуск программы.
    *   **Действие:** Отправка пакета `SYN (Seq=0)`. Запуск таймера.
    *   **Событие:** Таймаут. **Действие:** Повторная отправка `SYN`.
    *   **Событие:** Получение `SYN-ACK`. **Действие:** Переход в `TRANSFER`. Установка `Base=1`, `NextSeq=1`.

2.  **TRANSFER (Передача данных):**
    *   **Действие (цикл):** Пока `NextSeq < Base + N` и есть данные: создать пакет `DATA`, отправить, `NextSeq++`.
    *   **Событие:** Получение `ACK(n)`.
        *   Если `n >= Base`: `Base = n + 1`. Сброс таймера.
    *   **Событие:** Таймаут.
        *   **Действие:** Повторная отправка всех пакетов от `Base` до `NextSeq - 1`. Перезапуск таймера.
    *   **Условие выхода:** `Base > TotalPackets`. Переход в `TEARDOWN`.

3.  **TEARDOWN (Завершение):**
    *   **Действие:** Отправка пакета `FIN`. Запуск таймера.
    *   **Событие:** Получение `FIN-ACK`. **Действие:** Завершение работы (Exit Success).
    *   **Событие:** Таймаут. **Действие:** Повтор `FIN` (до 5 попыток), затем принудительный выход.

### 4.2. FSM Получателя

Получатель имеет два основных состояния:

1.  **WAIT_SYN (Ожидание подключения):**
    *   **Событие:** Получение `SYN`.
    *   **Действие:** Создание/очистка целевого файла. Установка `ExpectedSeq=1`. Отправка `SYN-ACK`. Переход в `WAIT_DATA`.

2.  **WAIT_DATA (Прием данных):**
    *   **Событие:** Получение `DATA (Seq=k)`.
        *   **Если** `k == ExpectedSeq` и `Checksum OK`:
            *   Записать Payload в файл.
            *   Отправить `ACK(k)`.
            *   `ExpectedSeq++`.
        *   **Иначе (k != ExpectedSeq или Error):**
            *   Отбросить пакет.
            *   Отправить `ACK(ExpectedSeq - 1)` (повтор подтверждения последнего успешного).
    *   **Событие:** Получение `SYN` (дубликат рукопожатия).
        *   **Действие:** Повторная отправка `SYN-ACK` (клиент мог потерять первый ACK).
    *   **Событие:** Получение `FIN`.
        *   **Действие:** Отправка `FIN-ACK`. Закрытие файла. Завершение работы.

---

## 5. Технические детали реализации

### 5.1. Управление ресурсами (RAII)
Проект использует C++20. Для работы с сокетами используется класс-обертка `RdtSocket`, который инкапсулирует системный файловый дескриптор.
*   **Конструктор:** Создает UDP сокет (`socket(AF_INET, SOCK_DGRAM)`).
*   **Деструктор:** Автоматически вызывает `close()`, предотвращая утечки ресурсов.

### 5.2. Обработка таймаутов
Вместо создания отдельного потока для таймера или использования `SIGALRM`, используется механизм таймаута на сокете:
```cpp
struct timeval tv;
tv.tv_sec = 0;
tv.tv_usec = timeout_ms * 1000;
setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
```
Это переводит блокирующий вызов `recvfrom` в режим ожидания с таймаутом. Если пакет не пришел за указанное время, функция возвращает ошибку, которая интерпретируется конечным автоматом отправителя как событие **Timeout**.
