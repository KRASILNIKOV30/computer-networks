### Краткое описание архитектуры проекта

Данный документ описывает архитектуру клиент-серверного приложения, написанного на языке C++. Проект демонстрирует базовые принципы сетевого взаимодействия по протоколу TCP/IP

#### 1. Общая структура проекта

Проект состоит из двух основных исполняемых модулей:
*   **Сервер**: ожидает подключения клиентов, принимает от них числовые данные, обрабатывает их и отправляет ответ.
*   **Клиент**: подключается к серверу, отправляет ему числовые данные, получает ответ и выводит результат.

Логика работы приложения разделена на несколько ключевых классов, каждый из которых отвечает за определенную часть функциональности. Такой подход обеспечивает модульность и упрощает понимание и дальнейшее развитие проекта.

#### 2. Ключевые компоненты архитектуры

##### 2.1. Управление ресурсами с помощью RAII

Центральной идеей, заложенной в архитектуру проекта, является использование идиомы RAII (Resource Acquisition Is Initialization) для управления системными ресурсами, такими как файловые дескрипторы сокетов. Эта идиома гарантирует, что ресурсы будут автоматически освобождены при выходе объекта, управляющего ресурсом, из области видимости, даже в случае возникновения исключений.

**Класс `FileDesc`**

Этот класс является низкоуровневой оберткой над файловым дескриптором (в данном контексте — дескриптором сокета). Он реализует следующие принципы:
*   **Инкапсуляция**: скрывает сырой файловый дескриптор и предоставляет безопасные методы для работы с ним.
*   **Управление временем жизни**: конструктор класса получает во владение файловый дескриптор, а деструктор автоматически закрывает его с помощью системного вызова `close()`.
*   **Запрет копирования**: объекты `FileDesc` нельзя копировать, чтобы избежать двойного закрытия одного и того же дескриптора.
*   **Поддержка перемещения**: реализованы конструктор и оператор присваивания перемещения для эффективной передачи владения ресурсом.

##### 2.2. Абстракции для работы с сокетами

Для упрощения работы с сетевым взаимодействием введены классы-обертки, которые предоставляют более высокоуровневый и объектно-ориентированный интерфейс к системным вызовам для работы с сокетами.

**Класс `Socket`**

Представляет собой обертку над `FileDesc` и предоставляет базовые операции для чтения и записи данных в сокет. Он инкапсулирует логику системных вызовов `read()` и `send()` и добавляет логирование операций ввода-вывода.

**Класс `Connection`**

Этот класс отвечает за установку и поддержание соединения со стороны клиента. Он инкапсулирует логику системных вызовов `socket()`, `inet_pton()` и `connect()`. Предоставляет удобные методы `Send` и `Receive` для обмена строковыми сообщениями с сервером.

**Класс `Acceptor`**

Данный класс используется на стороне сервера для приема входящих соединений. Он инкапсулирует логику системных вызовов `socket()`, `bind()` и `listen()`. Метод `Accept` блокирует выполнение до тех пор, пока не будет установлено новое клиентское соединение, после чего возвращает объект `Socket` для взаимодействия с этим клиентом.

#### 3. Логика работы приложения

##### 3.1. Серверная часть

Сервер инициализирует `Acceptor`, который начинает прослушивать указанный порт. В цикле сервер ожидает подключения новых клиентов. При подключении клиента `Acceptor` создает для него новый `Socket` и передает его в функцию `HandleClient`.

Функция `HandleClient` в цикле читает данные из сокета, обрабатывает их с помощью `HandleRequest` и отправляет ответ. Сервер завершает свою работу, если получает от клиента число вне заданного диапазона (1-100).

##### 3.2. Клиентская часть

Клиент создает объект `Connection`, который устанавливает соединение с сервером по указанному адресу и порту. После успешного подключения клиент запрашивает у пользователя число, формирует сообщение и отправляет его на сервер. Затем клиент ожидает ответ от сервера, обрабатывает его с помощью функции `HandleResponse` и выводит результат на экран.

#### 4. Обработка командной строки

Приложение поддерживает запуск в двух режимах: "server" и "client". Парсинг аргументов командной строки реализован в функции `ParseCommandLine`, которая возвращает `std::variant<HelpMode, ClientMode, ServerMode>`. Это позволяет статически безопасно обрабатывать различные режимы работы программы.
